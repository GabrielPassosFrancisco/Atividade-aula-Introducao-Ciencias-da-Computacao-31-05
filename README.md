# Atividade-aula-Introducao-Ciencias-da-Computacao-31-05
  Esse código é fácil de entender, nas primeiras linha do código importamos as bibliotecas Numpy e OpenCv, a biblioteca Numpy é mais usada quando o script tem muito dados circulando, e o OpenCv é responsável por cuidar da parte do processamento de imagens do código, logo após armazenamos 3 imagens em variáveis diferentes, e como atributo do cv2.imread() é 0, ele vai ler as imagens só que em escala cinza, e logo após armazena a largura e a altura dentro das duas variáveis usando o .shape da imagem base, e logo após cria uma matriz 5 por 5 compostos apenas do número 1 e depois armazena ele dentro da variável "kernel", logo após essa matriz "passa por cima" da imagem e cada pixel vai retornar o valor 1, porém no caso do cv2.erode vai ser apenas 1 se todos os pixels retornados sejam iguais a 1, essa função é literalmente uma erosão da imagem, assim os pixels próximos ao limite da imagem são apagados fazendo assim parecer menor, já a função cv2.dilate é o contrário da outra... ela serve para aumentar a imagem, e essas duas funções estão sendo usadas para armazenar dentro das variáveis "erosion e "dilation", logo após usamos outra função chamada de cv2.morphologyEx que serve como parametro a imagem base, função da biblioteca especifica da biblioteca e a matriz "kernel" resumindo ele é uma função que utiliza o cv2.erode e cv2.dilate como base para operações mais avançada, o cv2.MORPH_GRADIENT é a dierença entre esses dois, assim parecendo um contorno em volta da imagem, o cv2.MORPH_OPEN utiliza primeiro o cv2.erode e depois o cv2.dilate, ele serve para remover os ruídos das imagens, e por último o cv2.MORPH_CLOSE, ele é o inverso do cv2.MORPH_GRADIENT então el primeiro usa o cv2.dilate e só depois o cv2.erode assim removendo pequenos bucaros presentes na imagem, e cada um deles estão sendo atribuidos em três variáveis gradient, opening e closing respectivamente, e nas últimas linhas tem a função cv2.imshow que serve para exibir em janelas as imagens, como primeiro parametro que recebe é o nome da janela e como segundo argumento o nome da variavel ou função, e por último mas não menos importante... o código original do trabalho não rodava no código de Python, ele apenas rodava no collab, aqueles dois últimos comando são os cv2.waitKey(0) que serve para as janelas permancerem abertas até o úsuario pressionar "Enter", e depois tem o cv2.destroyAllWindows() que serve para fechar todas as janelas que foram abertas pelo script, e por último as imagens que retornavam não estavam corretas(tirando o das variáveis "erosion" e d"içation") então eu criei outra variável de matriz 11 por 11, que melhorou o resultado.
